# Entity Component System in C++

This repository contains code for a simple ECS in C++.
This project does not use RTTI; it uses generic containers for components and an archetype based type of memory structure.

## ECS Memory Type

The goal of ECS is to have faster throughput with fewer cache misses. The typical way to solve this is by having each archetype (a combination of components) hold arrays for each component. Then, when we want to query a group of archetypes, we access each individual container for the component values. This is pretty efficient if we take the case where there are $k$ components and each archetype is populated to a full cache line: there will be $2^{(k-n)} - 1$ cache misses where $n$ represents the component count of the smallest archetype in the group. My problem with this approach is that we make the assumption that the user of the ECS will use all archetypes and all groups. This is not always the case, nor is it the likely case.

Take the case where each archetype only has one entity in it. We perform the same amount of cache misses, but now we have way less data! This is where the idea of fast and slow paths comes in. Say we have three components: A, B, and C. We will have two systems, one that cares about C and one that cares about AB. The first system has a query or grouping that looks like C -> AC -> BC -> ABC and the second system has one that looks like AB -> ABC. What we can do for the fast path is say we want to optimise C since it has the most cache misses (4). Instead of treating each archetype independently, we will merge their respective containers together. This gives the first system a single cache miss (assuming the size of component C is 1/4 or less than the size of the cache line). However, you may notice the second system also needs ABC but now it needs component C. Here, instead of the archetype ABC pointing to its own container, it indexes into C's container and allows the second system to work with the same two cache misses.

How do I optimise this automatically? We can either let the user manually do it or we can base it off of the length of the path (for example, a system with C -> ABCD would not be optimised over AB -> ABD -> ABCD as this path has more archetypes and thus more misses). Furthermore, we can have a hierarchy. Let's say our system accesses C all the time, B a bit less often, and A the least, with all archetypes being in existence. Here, we can set [C -> AC -> BC -> ABC] as the fast path, [B -> AB] -> [BC -> ABC] as the next fastest path, and finally [A] -> [AB] -> [AC] -> [ABC] as the slowest path.

The issue can arise when we first create the path. Let's say we have $n$ entities in each. That means when we resize C, we have to make it fit at least $4n$ and then we have to copy all of the arrays over. That is why it is better to add paths before we add entities. This way, we can change the archetypes so that they already point to the containers in C and then update the pointers into C as we update the amount of entities per each archetype (in other words, we only pay the cost once).

A general issue for archetypes is deleting and adding consistently. If we were to make a particle simulation where we have thousands to millions of entities created and destroyed, we will be constantly resizing our arrays and having to shuffle to fill any gaps in the containers. We can solve the resizing problem by allowing a non-resize tag to be passed with calls to delete. Furthermore, we should also allow the user to predefine the size of the archetypes so we don't have to resize the array ever. Another issue is gaps. Shuffling can be done fairly quickly by just moving the last entity of the archetype to whatever gaps are before it. This way, we only shuffle as many as we delete. This could be problematic if every gap is at least a cache line away, meaning we can miss one for every gap we have (which could be many in a particle system). We can solve this in this case since, as I said before about understanding the actual use cases, we have an idea of how the data is actually used and accessed. In a particle system, we already know that the user is likely to set a timer for each particle and then delete it when it hits zero. As such, we can order the component arrays by the timer component. This way, when we delete the entities, we delete a batch of the components and can fill in batches, allowing for fewer cache misses overall. Thus, we should also have a way for the user to specify the order.
